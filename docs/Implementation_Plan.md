### **TDDによる実装計画：グラフRAGチャットシステム**

#### **前提：テストの哲学とツール**

*   **テストフレームワーク**: `pytest` を使用します。豊富なアサーション機能とプラグインエコシステムが強力です。
*   **モック**: 外部API（OpenAI）や重い処理（`LLMGraphTransformer`）は `unittest.mock` を使ってモック化し、テストを高速かつ独立させます。
*   **テスト用データベース**: 開発用・本番用とは完全に分離した**テスト専用のNeo4jデータベース**を用意します。各テストの前後でデータベースをクリーンな状態に保つ仕組み（`pytest`の`fixture`を利用）を構築します。これにより、テストの独立性と再現性を担保します。
*   **環境変数**: データベース接続情報やAPIキーは `.env` ファイルと `python-dotenv` ライブラリで管理し、テスト環境と開発環境で設定を切り替えられるようにします。

---

### **実装サイクル計画**

#### **サイクル 0: プロジェクトのセットアップと接続テスト**

**ゴール**: 開発の土台を整え、外部サービス（Neo4j, OpenAI）への基本的な接続をテストで保証する。

1.  **レッド**: Neo4jへの接続を試み、失敗するテスト (`test_neo4j_connection`) を書く。
2.  **グリーン**: 環境変数から接続情報を読み込み、`Neo4jGraph()` オブジェクトを初期化して接続を確立する最小限のコードを実装する。テストが通ることを確認。
3.  **レッド**: OpenAI API（埋め込みモデル）への接続を試み、失敗するテスト (`test_openai_embedding_connection`) を書く。
4.  **グリーン**: APIキーを読み込み、`OpenAIEmbeddings()` を初期化して、ダミーテキストの埋め込みを試みるコードを実装する。テストが通ることを確認。
5.  **リファクタリング**: 接続情報やクライアント初期化のロジックを、設定管理用のモジュール (`config.py`など) に整理する。テスト用DBのセットアップとクリーンアップを行う `pytest` の `fixture` を作成する。

#### **サイクル 1: ナレッジグラフ構築のコアロジック**

**ゴール**: 単一のテキストチャンクから知識グラフを抽出し、テスト用DBに正しく格納できることを保証する。

1.  **レッド**: `LLMGraphTransformer` の `convert_to_graph_documents` を呼び出し、期待通りの `GraphDocument` オブジェクトが返されることを検証する**失敗するテスト** (`test_document_to_graph_conversion`) を書く。
    *   **重要**: このテストでは、`LLMGraphTransformer`が内部で呼び出すLLMを**モック**します。固定のJSON応答を返すように設定し、LLM APIの呼び出しを不要にすることで、テストを高速かつ決定的にします。
2.  **グリーン**: テキストチャンクを受け取り、モックされた`LLMGraphTransformer`を呼び出して `GraphDocument` を返すラッパー関数を実装する。
3.  **レッド**: `GraphDocument` を受け取り、テスト用DBに格納した後、DB内のノードと関係性の数をCypherクエリで検証する**失敗するテスト** (`test_storing_graph_document_in_neo4j`) を書く。テスト後にはDBをクリーンアップする `fixture` が動くようにします。
4.  **グリーン**: `graph.add_graph_documents()` を呼び出して`GraphDocument`をDBに格納する最小限のコードを実装する。`include_source=True` と `baseEntityLabel=True` の効果（`:Document`ノードや`:MENTIONS`関係の存在）もテストでアサートします。
5.  **リファクタリング**: これまで実装した機能を `DataIngestor` のようなクラスにまとめ、責務を明確にする。

#### **サイクル 2: ベクトルインデックスの構築**

**ゴール**: グラフ内の `:Document` ノードに対して、ベクトルインデックスと全文検索インデックスが正しく作成されることを保証する。

1.  **レッド**: テストDBにいくつかの `:Document` ノードを準備した後、インデックスが存在しないことを確認し、ベクトルストアを初期化する関数を呼び出した後、Neo4jの `SHOW INDEXES` コマンドで**ベクトルインデックスと全文検索インデックスが作成されたこと**を検証する**失敗するテスト** (`test_vector_index_creation`) を書く。
    *   **注意**: 埋め込みモデル（`OpenAIEmbeddings`）は、実際のAPIを呼ばないようにモック化することが望ましいです。
2.  **グリーン**: `Neo4jVector.from_existing_graph` を呼び出し、インデックスを作成する関数を実装する。
3.  **リファクタリング**: インデックス構築ロジックを `DataIngestor` クラスのメソッドとして統合する。

#### **サイクル 3: 検索・応答チェーンの構築**

**ゴール**: ハイブリッド検索とLLM呼び出しを組み合わせたRAGチェーンの各部品が、正しく連携して動作することを保証する。

1.  **レッド**: ベクトル検索リトリーバーが、与えられた質問文字列で `invoke` されることを検証する**失敗するテスト** (`test_vector_retriever_invocation`) を書く。リトリーバー自体はモックします。
2.  **グリーン**: 質問を受け取り、ベクトル検索リトリーバーを呼び出す部分を実装する。
3.  **レッド**: グラフ検索チェーン（`GraphCypherQAChain`）が、質問文字列で `invoke` されることを検証する**失敗するテスト** (`test_graph_chain_invocation`) を書く。これもチェーン自体はモックします。
4.  **グリーン**: 質問を受け取り、グラフ検索チェーンを呼び出す部分を実装する。
5.  **レッド**: モックされたベクトル検索結果とグラフ検索結果を受け取り、**最終的なLLMへのプロンプトが期待通りのフォーマットで組み立てられること**を検証する**失敗するテスト** (`test_final_prompt_formation`) を書く。これはLLMの応答品質を制御する上で最も重要なテストの一つです。
6.  **グリーン**: 2つの検索結果を統合し、`PromptTemplate` に当てはめるロジックを実装する。
7.  **レッド**: RAGチェーン全体のエンドツーエンドのテスト (`test_rag_chain_end_to_end`) を書く。リトリーバー、グラフチェーン、最終的なLLM呼び出しを**全てモック**し、チェーン全体が正しくパイプとして繋がっていることを確認します。
8.  **グリーン**: LangChain Expression Language (LCEL) を用いて、各コンポーネントを結合し、`rag_chain` を完成させる。
9.  **リファクタリング**: チェーン構築のロジックを `QueryHandler` のようなクラスにカプセル化し、再利用しやすくする。

#### **サイクル 4: UIバックエンドロジックの実装**

**ゴール**: Streamlit UIから呼び出されるバックエンド関数が、RAGチェーンを適切に利用し、UIフレンドリーな形式で結果を返すことを保証する。

1.  **レッド**: ユーザーからの質問文字列を受け取り、`rag_chain` を呼び出して、その結果（生成された回答）を返すことを検証する**失敗するテスト** (`test_answer_generation_handler`) を書く。`rag_chain` はモックし、固定の文字列を返すようにします。
2.  **グリーン**: Streamlitから呼び出すためのハンドラ関数 `handle_query(question: str)` を実装する。
3.  **レッド**: グラフ可視化のために、エンティティ名をキーにDBを検索し、その結果を `Pyvis` や `streamlit-agraph` が要求するノードとエッジのリスト形式に変換することを検証する**失敗するテスト** (`test_graph_visualization_data_formatting`) を書く。DBからの応答は固定の辞書リストとします。
4.  **グリーン**: Cypherクエリの結果を受け取り、グラフライブラリ用のデータ構造に変換する関数を実装する。
5.  **リファクタリング**: `handle_query` 関数が、回答文字列とグラフデータの両方を含む辞書を返すように修正する。この関数を `app.py` などのStreamlitが直接呼び出すファイルに配置する。

この計画に従うことで、各機能が独立してテストされ、システムの全体像が徐々に組み上がっていきます。UIの実装（Streamlitのウィジェット配置など）は、このバックエンドロジックが完成した後に、それを呼び出す形で進めるのがスムーズです。
